# Sim

```elixir
Mix.install([
  {:kino, "~> 0.10.0", only: [:dev]},
  {:ximula, path: Path.join(__DIR__, ".."), env: :dev}
])
```

## Structs

```elixir
defmodule Sim.Entity do
  # %Sim.Vegetation{size: 5, capacity: 50, ...}
  defstruct id: nil, type: Sim.Entity, value: 0
end

defmodule Sim.Field do
  defstruct position: nil,
            priority: :normal,
            vegetation: [],
            herbivores: [],
            predators: [],
            factories: [],
            buildings: [],
            transports: [],
            pawns: []
end
```

## Data

```elixir
defmodule Sim.Data do
  use Agent

  alias Ximula.{Grid, Torus}
  alias Sim.Field

  def start_link(size) do
    Agent.start_link(fn ->
      Torus.create(size, size, fn x, y ->
        %Field{
          position: {x, y},
          vegetation: %Sim.Entity{type: Sim.Vegetation}
        }
      end)
    end)
  end

  def all(pid) do
    Agent.get(pid, & &1)
  end

  def get_field(x, y, pid) do
    Agent.get(pid, fn map -> Torus.get(map, x, y) end)
  end

  def get_all_fields(pid) do
    Agent.get(pid, &Grid.values(&1))
  end

  def positions(pid) do
    Agent.get(pid, &Grid.map(fn x, y, _ -> {x, y} end))
  end

  def set_fields(fields, pid) do
    Agent.update(pid, fn grid ->
      Enum.reduce(fields, grid, fn field, acc ->
        {x, y} = field.position
        Torus.put(acc, x, y, field)
      end)
    end)
  end

  def update_field({x, y}, field, pid) do
    Agnet.update(pid, fn gried -> Grid.update(x, y, field) end)
  end
end
```

```elixir
{:ok, map_pid} = Sim.Data.start_link(50)
{:ok, proxy} = Ximula.AccessData.start_link(data: map_pid, name: :sim_proxy)
Ximula.AccessData.get_by(proxy, &Sim.Data.get_field(0, 0, &1))
```

## Simulations

```elixir
defmodule Sim.Vegetation do
  alias Sim.Data
  alias Ximula.AccessData

  def change(position, world) do
    position
    |> AccessData.lock(world, &Data.get_field(&1, &2))
    |> sim()
    |> update(position, world)
  end

  def sim(field) do
    # Process.sleep(5)
    if field.position == {13, 13}, do: raise("Sim Error")
    put_in(field.vegetation.value, 1)
  end

  def update(field, position, data) do
    AccessData.update(position, field, data, fn data, position, value ->
      Data.update_field(position, value, data)
    end)
  end
end

defmodule Sim.Herbivore do
  def sim(field) do
    # Process.sleep(5)
    field
  end
end

defmodule Sim.Predator do
  def sim(_field) do
    :no_change
  end
end

defmodule Sim.Factory do
  def sim(_field) do
    :no_change
  end
end

defmodule Sim.Transport do
  def sim(_field) do
    :no_change
  end
end
```

## Simulator

```elixir
defmodule FieldSimulator do
  alias Ximula.Simulator
  alias Ximula.Sim.Queue
  alias Ximula.AccessData
  alias Sim.Data

  @simulations [
    Sim.Vegetation,
    Sim.Herbivore,
    Sim.Factory,
    Sim.Predator,
    Sim.Transport
  ]

  def run_queue(%Queue{} = queue, opts) do
    Enum.map(@simulations, &sim_simulation(queue, &1, opts))
    |> aggregate_results(queue.name)
    |> notify_sum()
  end

  def sim_simulation(queue, simulation, opts) do
    Simulator.benchmark(fn ->
      get_positions(opts[:proxy], queue.name)
      |> Simulator.sim({simulation, :change, [opts[:proxy]]}, & &1.position)
      |> handle_success(opts[:proxy])
      |> handle_failed(opts[:proxy])
      |> summarize(simulation)
      |> notify()
    end)
  end

  def get_positions(proxy, _name) do
    AccessData.get_by(proxy, &Data.positions(&1))
  end

  def handle_success(%{ok: fields} = results, _proxy) do
    IO.puts("successful simulations: #{Enum.count(fields)}")
    results
  end

  def handle_failed(%{exit: failed} = results, _proxy) do
    Enum.each(failed, fn reason ->
      IO.puts("failed simulations: #{Exception.format_exit(reason)}")
    end)

    results
  end

  def summarize(%{ok: success, exit: failed}, simulation) do
    %{
      simulation: simulation,
      ok: Enum.map(success, & &1.position),
      error:
        Enum.map(failed, fn {id, {exception, stacktrace}} ->
          {id, Exception.normalize(:exit, exception, stacktrace) |> Exception.message()}
        end)
    }
  end

  # [{1097, %{error: [], ok: [], simulation: Sim.Vegetation}}]
  def aggregate_results(results, queue) do
    %{
      queue: queue,
      results:
        Enum.map(results, fn {time, %{error: error, ok: ok, simulation: simulation}} ->
          %{simulation: simulation, time: time, errors: Enum.count(error), ok: Enum.count(ok)}
        end)
    }
  end

  def notify_sum(results) do
    # PubSub.broadcast(topic, queue_result) | GenStage.cast(stage, {:receive, queue_result})
    dbg(results)
  end

  def notify(%{error: _error, ok: _ok, simulation: _simulation} = result) do
    # %{simulation: simulation, changed: ok} |> dbg()
    # %{simulation: simulation, failed: error} |> dbg()
    # PubSub.broadcast(topic, change) | GenStage.cast(stage, {:receive, change})
    result
  end
end
```

```elixir
Task.Supervisor.start_link(name: Ximula.Simulator.Task.Supervisor)
Task.Supervisor.start_link(name: Ximula.Sim.Loop.Task.Supervisor)
Ximula.Sim.Loop.start_link(sim_args: [proxy: :sim_data])
```

```elixir
Ximula.Sim.Loop.add_queue(%Ximula.Sim.Queue{
  name: :high,
  func: {FieldSimulator, :run_queue, [proxy: :sim_proxy]},
  interval: 500
})

Ximula.Sim.Loop.add_queue(%Ximula.Sim.Queue{
  name: :normal,
  func: &FieldSimulator.run_queue/2,
  interval: 2_000
})

Ximula.Sim.Loop.add_queue(%Ximula.Sim.Queue{
  name: :low,
  func: &FieldSimulator.run_queue/2,
  interval: 10_000
})
```

```elixir
Ximula.Sim.Loop.start_sim()
Process.sleep(5_000)
Ximula.Sim.Loop.stop_sim()
```

```elixir
Sim.Data.all(map_pid)
```
