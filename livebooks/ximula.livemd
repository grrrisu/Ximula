<!-- livebook:{"app_settings":{"slug":"ximula"}} -->

# Ximula

```elixir
Mix.install([
  {:kino, "~> 0.18.0", only: [:dev]},
  {:ximula, path: Path.join(__DIR__, ".."), env: :dev}
])
```

## Overview

This Livebook demonstrates the Ximula.Sim framework - a composable, pipeline-based simulation library for Elixir. The framework separates simulation logic (pure functions) from execution strategy (parallel/sequential) and provides observability through Telemetry and PubSub.

<!-- livebook:{"break_markdown":true} -->

```mermaid
graph TB
    Supervisor[Supervisor<br/>strategy: :rest_for_one]
    
    Supervisor --> Agent[Agent: MyWorld<br/>holds grid data]
    Supervisor --> GK[Gatekeeper<br/>locked access wrapper]
    Supervisor --> PubSub[Phoenix.PubSub<br/>event broadcasting]
    Supervisor --> LoopTaskSup[Task.Supervisor<br/>loop tasks]
    Supervisor --> RunnerTaskSup[Task.Supervisor<br/>simulation tasks]
    Supervisor --> Loop[Loop GenServer<br/>queue orchestration]

    style Agent fill:#90EE90
    style GK fill:#90EE90
    style Loop fill:#FFB6C1
    style PubSub fill:#87CEEB
    style LoopTaskSup fill:#FFD700
    style RunnerTaskSup fill:#FFD700
```

<!-- livebook:{"break_markdown":true} -->

### Architecture

* Gatekeeper: Holds world state (Grid), provides locked concurrent access
* Loop: GenServer that orchestrates queues, manages timers and tasks
* Queue: Defines when and what to execute (interval + filter function)
* Pipeline: Sequence of stages (e.g., vegetation → population → movement)
* Stage: Uses an adapter (Single, Grid, Gatekeeper) to process entities
* Steps: Pure simulation functions that return changes

### Three Levels of Execution

#### Queue / Loop (Timing & Orchestration)

* **Purpose**: Schedules when to run, filters what to process
* **Properties**: name, interval, func (filter + pipeline execution)
* **Implementation**: GenServer manages queue lifecycle
* **Execution**: Each queue runs its filter → pipeline in supervised task
* **API**: `Loop.add_queue(loop, queue)`, `Loop.start_sim(loop)`
* **Example**: Urgent queue runs every 100ms, processes fields where `urgent == true`
* **State**: Ephemeral (queues can be rebuilt on restart)

#### Pipeline / Stage (Coordination & Execution Strategy)

* **Purpose**: Defines what runs and how (sequential stages)
* **Properties**: stage sequence, stage adapter, notification config
* **Execution**: 
  * Calls `TaskRunner` for parallel execution
  * Adapters handle data shape (Grid, Single, Gatekeeper)
  * Gatekeeper adapter locks positions, reads/writes through Gatekeeper
* **API**: `Pipeline.execute(pipeline, state)`
* **Example**: Stage 1: grow_crops → Stage 2: consume_food
* **State**: Static (built once, stored as module functions or config)

#### Simulation / Step (Pure Logic)

* **Purpose**: Implements game/simulation rules
* **Properties**: Pure functions, no side effects
* **Signature**: `def step(%Change{data, changes}, opts)`
* **Returns**: `%Change{changes: %{key: value}}`
* **API**: `Vegetation.grow_crops(change)`
* **Example**: Calculate crop growth based on water + soil
* **Events**: Emit telemetry/pubsub events for significant changes

#### Execute one Tick

<!-- livebook:{"break_markdown":true} -->

```mermaid
sequenceDiagram
  participant Timer
  participant EventLoop as Loop
  participant Queue
  participant GK as Gatekeeper / Data
  participant Pipeline
  participant Adapter as Stage Adapter
  participant TaskRunner
  participant SimStep as Sim Step

  Timer->>EventLoop: Tick
  EventLoop->>Queue: Execute queue.func()
  Queue->>GK: Get all positions
  GK-->>Queue: positions list
  Queue->>Pipeline: execute with positions
  Pipeline->>Adapter: run_stage
  Adapter->>GK: lock positions and read
  GK-->>Adapter: field data
  Adapter->>TaskRunner: sim with execute_steps
  
  par Parallel Execution
    TaskRunner->>SimStep: position (0,0)
    TaskRunner->>SimStep: position (0,1)
    TaskRunner->>SimStep: position (1,0)
    TaskRunner->>SimStep: position (1,1)
  end
  
  SimStep-->>TaskRunner: changes vegetation
  TaskRunner-->>Adapter: all changes collected
  Adapter->>GK: update_multi with changes
  GK-->>Adapter: ok
  Adapter-->>Pipeline: ok with results
  Pipeline-->>Queue: ok with data
  Queue-->>EventLoop: ok with data
```

## Setup

```elixir
defmodule MySimulation do
  @moduledoc """
  A simple vegetation growth simulation demonstrating Ximula.Sim framework.
  
  The simulation:
  - Creates a 2D torus (wrapping grid) world
  - Each field has vegetation that grows by 1 each tick
  - Uses Gatekeeper for locked concurrent access
  - Demonstrates telemetry and PubSub events
  """
  alias Phoenix.PubSub
  
  alias Ximula.{Grid, Torus}
  alias Ximula.Gatekeeper.Agent, as: Gatekeeper
  alias Ximula.Sim.{Change, Loop, Pipeline, Queue}
  alias Ximula.Sim.StageAdapter.Gatekeeper, as: GatekeeperAdapter  

  @doc """
  Starts the simulation supervision tree.
  
  Uses :rest_for_one strategy - if Gatekeeper crashes, everything restarts.
  If Loop crashes, Gatekeeper (data) survives.
  """
  def start do
    children = [
      # Data layer - if this crashes, everything downstream is invalid
      Gatekeeper.agent_spec(MyWorld, data: nil, name: :world),
      {Ximula.Gatekeeper.Agent, name: :gatekeeper, agent: :world},

      # Infrastructure - depends on data layer being healthy
      {PubSub, name: :my_pub_sub},
      {Task.Supervisor, name: :loop_task_supervisor},
      {Task.Supervisor, name: :task_runner_supervisor},

      # Orchestration - depends on all infrastructure
      {Loop, name: :my_sim_loop, supervisor: :loop_task_supervisor}
    ]
    Supervisor.start_link(children, strategy: :rest_for_one, name: :my_simulation)
  end
  
  def create_world(size) do
    world = Torus.create(size, size, fn _x, _y ->
      %{
        vegetation: 100
      }
    end)
    Gatekeeper.direct_set(:gatekeeper, fn _ -> world end)
  end

  def positions(gatekeeper) do
    Gatekeeper.get(gatekeeper, &Grid.positions(&1))
  end

  def get_field(position, gatekeeper) do
    field = Gatekeeper.lock(gatekeeper, position, &Grid.get(&1, position))
    Map.merge(field, %{position: position})
  end

  def put_field(%{position: position, vegetation: vegetation}, gatekeeper) do
    :ok = Gatekeeper.update(gatekeeper, position, vegetation, &Grid.put(&1, position, %{vegetation: vegetation}))
    position
  end

  def create_queue(pipeline) do
    %Queue{
      name: :normal,
      interval: 1_000
    } 
    |> Queue.add_pipeline(pipeline, %{
      data: positions(:gatekeeper), 
      opts: [tick: 0, supervisor: :task_runner_supervisor]
    })
  end

  def create_pipeline() do
    Pipeline.new_pipeline(notify: :event_metric, name: "sim_pipeline", pubsub: :my_pub_sub)
    |> Pipeline.add_stage(
      adapter: GatekeeperAdapter,
      gatekeeper: :gatekeeper,
      name: "field_stage", 
      notify: %{all: :event_metric, entity: {:event_metric, fn field -> field.position == {0, 0} end}},
      pubsub: :my_pub_sub,
      read_fun: &get_field/2,
      write_fun: &put_field/2
    )
    |> Pipeline.add_step(
      MySimulation, 
      :sim_vegetation, 
      notify: {:metric, fn change -> Change.get(change, :position) == {0, 0} end})
  end

  def sim_vegetation(%Change{data: %{vegetation: _vegetation}} = change) do
    Change.change_by(change, :vegetation, 1)
  end
  
end

```

## Start SimServer

```elixir
MySimulation.start()
```

```elixir
MySimulation.create_world(2)
```

```elixir
Agent.get(:world, & &1)
```

```elixir
queue = MySimulation.create_pipeline() |> MySimulation.create_queue()
Ximula.Sim.Loop.add_queue(:my_sim_loop, queue)
```

## Telemetry

```elixir
import Kino.Shorts

{:ok, data_agent} = Agent.start_link(fn -> [] end)
frame = Kino.Frame.new() |> Kino.render()
metric_table = Kino.DataTable.new([], keys: [:id, :time, :event, :duration])
Kino.Frame.render(frame, metric_table)

defmodule TelemetryTable do
  def handle_event(event, measurements, _meta, %{table: metric_table, agent: agent}) do
    data = Agent.get(agent, & &1)
    id = Map.get(measurements, :monotonic_time)
    data = [%{
      id: id, 
      time: DateTime.utc_now(),
      event: event, 
      duration: Map.get(measurements, :duration, 0) |> System.convert_time_unit(:native, :microsecond)
    } | data]
    Agent.update(agent, fn _ -> data end)
    Kino.DataTable.update(metric_table, data)
  end
end

:ok =
  :telemetry.attach_many(
    "ximula-metrics-#{:erlang.unique_integer()}",
    [
      [:ximula, :sim, :pipeline, :start],
      [:ximula, :sim, :pipeline, :stop],
      [:ximula, :sim, :pipeline, :stage, :start],
      [:ximula, :sim, :pipeline, :stage, :stop],
      [:ximula, :sim, :pipeline, :stage, :entity, :start],
      [:ximula, :sim, :pipeline, :stage, :entity, :stop],
      [:ximula, :sim, :pipeline, :stage, :step, :start],
      [:ximula, :sim, :pipeline, :stage, :step, :stop]
    ],
    &TelemetryTable.handle_event/4,
    %{table: metric_table, agent: data_agent}
  )

      
```

## Events

```elixir
defmodule EventListener do

  def start do
    Task.start(fn ->
      :ok = Phoenix.PubSub.subscribe(:my_pub_sub, "sim:pipeline:sim_pipeline")
      :ok = Phoenix.PubSub.subscribe(:my_pub_sub, "sim:pipeline:stage:field_stage")
      :ok = Phoenix.PubSub.subscribe(:my_pub_sub, "sim:pipeline:stage:field_stage:entity")
      listen_loop()
    end)
  end

  def listen_loop() do
    receive do
      msg -> IO.inspect(msg, label: "Received message")
    after
      1000 -> :ok
    end
    listen_loop()
  end

end
EventListener.start()
```

## Run Simulation

```elixir
Ximula.Sim.Loop.start_sim(:my_sim_loop)
Process.sleep(5_000)
Ximula.Sim.Loop.stop_sim(:my_sim_loop)
```

```elixir
Ximula.Gatekeeper.Agent.get(:gatekeeper, fn world -> Ximula.Grid.get(world, {1, 1}) end)
```

<!-- livebook:{"offset":9789,"stamp":{"token":"XCP.RGZh6kzuDc2F73JPRP4lN5MTohyoGkX4RFNoK3ItYGZIg0NKO__IHTHOXgZOmLIFpeUsWqDQ8lo65OB9gMzPy5IavsgXzoTJfKBIUS2GviLeQW_pqz6qqrYL","version":2}} -->
