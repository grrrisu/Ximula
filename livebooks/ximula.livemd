<!-- livebook:{"app_settings":{"slug":"ximula"}} -->

# Ximula

```elixir
Mix.install([
  {:kino, "~> 0.18.0", only: [:dev]},
  {:ximula, path: Path.join(__DIR__, ".."), env: :dev}
])
```

## Ximula Setup

```elixir
defmodule MySimulation do
  alias Phoenix.PubSub
  
  alias Ximula.{Grid, Torus}
  alias Ximula.Gatekeeper.Agent, as: Gatekeeper
  alias Ximula.Sim.{Change, Loop, Pipeline, Queue}
  alias Ximula.Sim.StageAdapter.Gatekeeper, as: GatekeeperAdapter  

  def start do
    children = [
      # Data layer - if this crashes, everything downstream is invalid
      Gatekeeper.agent_spec(MyWorld, data: nil, name: :world),
      {Ximula.Gatekeeper.Agent, name: :gatekeeper, agent: :world},

      # Infrastructure - depends on data layer being healthy
      {PubSub, name: :my_pub_sub},
      {Task.Supervisor, name: :loop_task_supervisor},
      {Task.Supervisor, name: :task_runner_supervisor},

      # Orchestration - depends on all infrastructure
      {Loop, name: :my_sim_loop, supervisor: :loop_task_supervisor}
    ]
    Supervisor.start_link(children, strategy: :rest_for_one, name: :my_simulation)
  end
  
  def create_world(size) do
    world = Torus.create(size, size, fn _x, _y ->
      %{
        vegetation: 100
      }
    end)
    Gatekeeper.direct_set(:gatekeeper, fn _ -> world end)
  end

  def positions(gatekeeper) do
    Gatekeeper.get(gatekeeper, &Grid.positions(&1))
  end

  def get_field(position, gatekeeper) do
    field = Gatekeeper.lock(gatekeeper, position, &Grid.get(&1, position))
    Map.merge(field, %{position: position})
  end

  def put_field(%{position: position, vegetation: vegetation}, gatekeeper) do
    :ok = Gatekeeper.update(gatekeeper, position, vegetation, &Grid.put(&1, position, %{vegetation: vegetation}))
    position
  end

  def create_queue(pipeline) do
    %Queue{
      name: :normal,
      interval: 1_000
    } 
    |> Queue.add_pipeline(pipeline, %{
      data: positions(:gatekeeper), 
      opts: [tick: 0, supervisor: :task_runner_supervisor]
    })
  end

  def create_pipeline() do
    Pipeline.new_pipeline(notify: :event_metric, name: "sim_pipeline", pubsub: :my_pub_sub)
    |> Pipeline.add_stage(
      adapter: GatekeeperAdapter,
      gatekeeper: :gatekeeper,
      name: "field_stage", 
      notify: %{all: :event_metric, entity: {:event_metric, fn field -> field.position == {0, 0} end}},
      pubsub: :my_pub_sub,
      read_fun: &get_field/2,
      write_fun: &put_field/2
    )
    |> Pipeline.add_step(
      MySimulation, 
      :sim_vegetation, 
      notify: {:metric, fn change -> Change.get(change, :position) == {0, 0} end})
  end

  def sim_vegetation(%Change{data: %{vegetation: _vegetation}} = change) do
    Change.change_by(change, :vegetation, 1)
  end
  
end

```

```elixir
MySimulation.start()
```

```elixir
MySimulation.create_world(2)
```

```elixir
Agent.get(:world, & &1)
```

```elixir
queue = MySimulation.create_pipeline() |> MySimulation.create_queue()
Ximula.Sim.Loop.add_queue(:my_sim_loop, queue)
```

```elixir
import Kino.Shorts

{:ok, data_agent} = Agent.start_link(fn -> [] end)
frame = Kino.Frame.new() |> Kino.render()
metric_table = Kino.DataTable.new([], keys: [:id, :time, :event, :duration])
Kino.Frame.render(frame, metric_table)

defmodule TelemetryTable do
  def handle_event(event, measurements, _meta, %{table: metric_table, agent: agent}) do
    data = Agent.get(agent, & &1)
    id = Map.get(measurements, :monotonic_time)
    data = [%{
      id: id, 
      time: DateTime.utc_now(),
      event: event, 
      duration: Map.get(measurements, :duration, 0) |> System.convert_time_unit(:native, :microsecond)
    } | data]
    Agent.update(agent, fn _ -> data end)
    Kino.DataTable.update(metric_table, data)
  end
end

:ok =
  :telemetry.attach_many(
    "ximula-metrics-#{:erlang.unique_integer()}",
    [
      [:ximula, :sim, :pipeline, :start],
      [:ximula, :sim, :pipeline, :stop],
      [:ximula, :sim, :pipeline, :stage, :start],
      [:ximula, :sim, :pipeline, :stage, :stop],
      [:ximula, :sim, :pipeline, :stage, :entity, :start],
      [:ximula, :sim, :pipeline, :stage, :entity, :stop],
      [:ximula, :sim, :pipeline, :stage, :step, :start],
      [:ximula, :sim, :pipeline, :stage, :step, :stop]
    ],
    &TelemetryTable.handle_event/4,
    %{table: metric_table, agent: data_agent}
  )

      
```

```elixir
defmodule EventListener do

  def start do
    Task.start(fn ->
      :ok = Phoenix.PubSub.subscribe(:my_pub_sub, "sim:pipeline:sim_pipeline")
      :ok = Phoenix.PubSub.subscribe(:my_pub_sub, "sim:pipeline:stage:field_stage")
      :ok = Phoenix.PubSub.subscribe(:my_pub_sub, "sim:pipeline:stage:field_stage:entity")
      listen_loop()
    end)
  end

  def listen_loop() do
    receive do
      msg -> IO.inspect(msg, label: "Received message")
    after
      1000 -> :ok
    end
    listen_loop()
  end

end
EventListener.start()
```

```elixir
Ximula.Sim.Loop.start_sim(:my_sim_loop)
Process.sleep(5_000)
Ximula.Sim.Loop.stop_sim(:my_sim_loop)
```

```elixir
receive do
  msg -> IO.inspect(msg, label: "Received message")
after
  1000 -> IO.puts("No message in 5 seconds")
end
```

```elixir
Ximula.Gatekeeper.Agent.get(:gatekeeper, fn world -> Ximula.Grid.get(world, {1, 1}) end)
```

<!-- livebook:{"offset":5262,"stamp":{"token":"XCP.jlB1lA0zfUyxg8p6qcOqwasxhxFWrGAZHzzjjj0rHGNkCExDdFTCroLXTohAGKsxVuBFq2AV4Q_TWV932MACxPvY--rtgBbIaFiHIUonWCotb4qWfh4lMH-E","version":2}} -->
